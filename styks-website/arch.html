<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>arch</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true });</script>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h1>Styks</h1>
<p>Styks is the very first Casper onchain price oracle.</p>
<p><a href="#toc">ToC</a></p>
<h2>Current Price</h2>
<div class="mermaid">
---
config:
  themeVariables:
    xyChart:
      titleColor: '#00ff00'
---

xychart-beta
    title "CSPRUSD Price Feed"
    x-axis ["01 Jan", "02 Jan", "03 Jan", "04 Jan", "05 Jan", "06 Jan", "07 Jan", "08 Jan", "09 Jan", "10 Jan", "11 Jan", "12 Jan"]
    y-axis "Price [$]" 0.015 --> 0.035
    line [.015, .016, .02, .025, .015, .02, .017, .021, .03, .027, .035, .033]
</div>

<h2>Onchain integration</h2>
<p>Before diving into details of how Styks works, if you just want to use the price
feed in your smart contract, just call <code>get_price</code> entry point of the
<code>StyksPriceFeed</code> smart contract. It returns the latest price for the requested
price_feed_id, or <code>None</code> if the price feed is not available.</p>
<p>You can integrate it into your smart contract using the <code>styks_price_feed</code> Rust
crate. Example of loading <code>CSPRUSD</code> price from the <code>StyksPriceFeed</code> smart
contract:</p>
<pre class="codehilite"><code class="language-rust">let price: Option&lt;u128&gt; = styks_price_feed::get_price(
    &quot;hash-123...890&quot;, // address of the StyksPriceFeed contract
    &quot;CSPRUSD&quot;, // price feed id
)
</code></pre>

<p>You can also use Odra-based integration to interact with the contract, use it in
tests, or include it in your CLI application.</p>
<p>TODO: Add example of Odra-based integration.</p>
<h2>Why does Casper need a price oracle?</h2>
<p>The price oracle is a piece of public infrastructure, that ports a price data
from the outside world to the blockchain in safe manner. Lack of it, prevented
Casper community from developing complex DeFi protocols, such as lending,
borrowing, derivatives, complex liquidity pools, leverage trading, prediction
markets and more.</p>
<p>Styks brings a reliable and secure price feeds to the Casper ecosystem for
others to build on top of it. </p>
<p><strong>It is free to use!</strong></p>
<h2>System High Level Architecture</h2>
<p>Styks architecture consists of four main components:
- Blocky Server -  for fetching the latest, signed prices from the CoinGecko
  API.
- Onchain smart contracts - <code>BlockyPriceFeed</code> and <code>StyksPriceFeed</code> for storing
  and operation the prices onchain.
- <code>PriceProducer</code> - offchain component, that is responsible for fetching the
  latest prices from the Blocky Server and posting them to the <code>BlockyPriceFeed</code>
  contract.
- <code>StyksAdmin</code> - admin account, that is responsible for maintaining the correct configuration of smart contracts.</p>
<div class="mermaid">
---
title: Styks Architecture Diagram
---

flowchart TB
    subgraph Offchain Actors
      PriceProducer
      StyksAdmin
    end

    subgraph Casper Blockchain
      OnchainConsumer
      BlockyPriceFeed
      StyksPriceFeed
    end

    subgraph Blocky Server
      BlockyAPI
      CoinGecko
    end

    %% Retrieve the latest price.
    OnchainConsumer -->|"get_price(symbol)"| StyksPriceFeed
    StyksPriceFeed -->|price| OnchainConsumer

    %% Bringing the price onchain using blocky.
    PriceProducer -->|"call guest program"| BlockyAPI
    BlockyAPI -->|"get_prices(symbols)"| CoinGecko
    CoinGecko -->|"prices"| BlockyAPI
    BlockyAPI -->|"prices"| PriceProducer
    PriceProducer -->|"post_prices(signed_prices)"| BlockyPriceFeed
    BlockyPriceFeed -->|"post_prices(prices)"| StyksPriceFeed

    %% Define price feeds.
    StyksAdmin -->|"configure"| StyksPriceFeed
    StyksAdmin -->|"configure"| BlockyPriceFeed
</div>

<h2>Blocky</h2>
<p>What makes Styks's architecture simple is using the
<a href="https://blocky-docs.redocly.app/">Blocky</a> service. It allows anyone to execute
arbitrary WASM file (aka guest program) and receive the result of its execution,
along with the signature of the result, confirming the authenticity of the data.
Guest programs can make HTTP requests which makes it perfect for Styks.</p>
<p>The guest program used in Styks does one thing - it fetches the all the latest
prices from the CoinGecko API and returns them as a single blob of data, signed
by the Blocky server. This allows for trusted architecture with a single
operator, later referred as the <code>PriceProducer</code>.</p>
<h2>Heartbeat</h2>
<p>Styks uses the heartbeat mechanism to control the price feed updates. It is a
simple, but effective way of scheduling tasks. It requires <code>PriceProducer</code> to
update the price feed once per given time interval, labelled as
<code>heartbeat_interval</code>. For example if the interval is 5 minutes, then heartbeats
are at 00:00, 00:05, 00:10, etc. If the <code>PriceProducer</code> misses the heartbeat,
then it should try to catch the next one.</p>
<p>It is not possible to send the updates exactly at the heartbeat time, so
<code>PriceProducer</code> is allowed to send it within some time around the heartbeat
time, defined as <code>heartbeat_tolerance</code>. For example if the tolerance is 
2 minutes, and the next heartbeat is at 11:05, then the <code>PriceProducer</code>
can send the update between 11:03 and 11:07 (inclusive).</p>
<p>Actions taken within the tolerance window are treated as they would happen
exactly at the heartbeat time. This decision was made to simplify the system's
design and allow for multiple <code>PriceProducers</code> to work in parallel in future.</p>
<p>Data can be sent only once per heartbeat, so if the <code>PriceProducer</code> sends
multiple updates within the tolerance window, only the first one is accepted
and the rest are rejected.</p>
<h2>Time Weighted Average Price (TWAP)</h2>
<p>Styks uses the Time Weighted Average Price (TWAP) algorithm to calculate the
price. Due to the interval nature of the heartbeat mechanism, which ensures
prices are updated in the constant intervals, the TWAP is calculated as a simple
average of the price records over the last few heartbeats, defined as
<code>twap_window</code>. It can be 1 (to use the latest price) or more.</p>
<p>Algorithm should also handle missed heartbeats and allow some amounts of
hertbeats to be missed before the price feed is considered invalid. It is
defined as <code>twap_tolerance</code>. If it is set to 0, then no missed heartbeats are
allowed. If 1 or more, then the price feed is still valid if the <code>PriceProducer</code>
missed 1 heartbeat. For example if <code>twap_window</code> is 3 and <code>twap_tolerance</code> is 2,
then the price feed is still valid if the <code>PriceProducer</code> missed 2 heartbeats,
within the last 3 heartbeats.</p>
<p>It still has the <code>TW</code> in its name, even that it is a simple average, but the
algorithm might be extended in the future to use more complex TWAP version if
heartbeat mechanism is changed.</p>
<h2>Price Feed Id</h2>
<p>Each price feed is identified by a unique identifier, called <code>PriceFeedId</code>. The
convention in Styks is to use the format <code>&lt;base_currency&gt;&lt;quote_currency&gt;</code>, for
example <code>CSPRUSD</code> for Casper to USD price feed. Each <code>PriceFeedId</code> have
associated information about the name of the CoinGecko symbol.</p>
<h2>StyksPriceFeed Smart Contract</h2>
<p>The <code>StyksPriceFeed</code> smart contract is the main smart contract of the system.
It has multiple security roles. Each role is responsible for different aspects
of the system.</p>
<p>The roles are defined as follows:
  - <code>AdminRole</code> - manages roles of other accounts,
  - <code>ConfigManagerRole</code> - manages price feeds and their configurations,
  - <code>PriceSupplierRole</code> - must supply the price with new data according to the
    heartbeat schedule,</p>
<p>Anyone can read the twap price using the <code>get_twap_price(price_feed_id)</code> entry
point. It returns the value or <code>None</code> if the price feed is not available, because
of the missed heartbeats or not being configured.</p>
<p>Configuration of the contract.
- <code>heartbeat_interval</code>,
- <code>heartbeat_tolerance</code>,
- <code>twap_window</code>,
- <code>twap_tolerance</code>,
- <code>price_feed_ids</code> - list of enabled price feeds.</p>
<h2>BlockyPriceFeed Smart Contract</h2>
<p>The <code>BlockyPriceFeed</code> smart contract is a bridge between the Blocky server and
the <code>StyksPriceFeed</code> smart contract. It is responsible for receiving the signed
prices from the <code>PriceProducer</code> and posting them to the <code>StyksPriceFeed</code>.</p>
<p>It is configured as follows:
- <code>blocky_wasm_hash</code> - hash of the Blocky server WASM file.
- <code>blocky_signing_key</code> - public key of the Blocky server, used to verify the
  signature of the prices.
- <code>styks_price_feed_address</code> - address of the <code>StyksPriceFeed</code> contract,
  where the prices are posted.
- <code>price_feed_id_metadata</code> - key-value map of the price feed ids and their
  associated metadata, such as CoinGecko symbol. Example:
    - (<code>CSPRUSD</code>, <code>CoinGecko</code>) -&gt; <code>casper-network</code>,
    - (<code>BTCUSD</code>, <code>CoinGecko</code>) -&gt; <code>bitcoin</code>.</p>
<p>It is also follows the security roles pattern:
  - <code>AdminRole</code> - manages roles of other accounts,
  - <code>ConfigManagerRole</code> - manages configuration of the contract,
  - <code>PriceSupplierRole</code> - supplies the output of the blocky server to the
    contract.</p>
<p><code>PriceProducer</code> must have the <code>PriceSupplierRole</code> role assigned in order to be
able to post the prices.</p>
<p>The <code>BlockyPriceFeed</code> contract must have the <code>PriceSupplierRole</code> role assigned
in the <code>StyksPriceFeed</code> contract in order to be able to post the prices. </p>
<h2>Update Price Feed Procedure</h2>
<h3>Step 1: <code>PriceProducer</code> offchain sequence:</h3>
<ul>
<li><code>PriceProducer</code> checks in the <code>StyksPriceFeed</code> when is the next heartbeat.</li>
<li>If the time is right, it starts the update procedure.</li>
<li><code>PriceProducer</code> load list of active <code>PriceFeedId</code>s and their <code>CoinGecko</code>
  symbols from the <code>BlockyPriceFeed</code> contract.</li>
<li><code>PriceProducer</code> calls the <code>BlockyAPI</code> with the list of symbols to
  fetch the latest prices. It uses the guest program that matches the
  <code>blocky_wasm_hash</code> configured in the <code>BlockyPriceFeed</code> contract.</li>
<li><code>BlockyAPI</code> responds with the signed prices.</li>
<li><code>PriceProducer</code> posts the signed prices to the <code>BlockyPriceFeed</code> contract.</li>
</ul>
<h3>Step 2: <code>BlockyPriceFeed</code> onchain sequence:</h3>
<ul>
<li><code>BlockyPriceFeed</code> checks if the caller has the <code>PriceSupplierRole</code> role.</li>
<li><code>BlockyPriceFeed</code> verifies data:</li>
<li>if the signature matches the <code>blocky_signing_key</code>,</li>
<li>if prices are valid,</li>
<li>if <code>blocky_wasm_hash</code> matches the one configured in the contract.</li>
<li>If all checks pass, it posts raw prices in the format of list(<code>PriceFeedId</code> -&gt;
  price) to the <code>StyksPriceFeed</code> contract.</li>
</ul>
<h3>Step 3: <code>StyksPriceFeed</code> onchain sequence:</h3>
<ul>
<li><code>StyksPriceFeed</code> checks if the caller has the <code>PriceSupplierRole</code> role.</li>
<li><code>StyksPriceFeed</code> for each price in the list checks the following:</li>
<li>the <code>PriceFeedId</code> is enabled,</li>
<li>the price is valid,</li>
<li>the time is within the heartbeat tolerance,</li>
<li>the price was not already posted in the current heartbeat.</li>
<li>For each valid price, it update the price of the <code>PriceFeedId</code> in the
  <code>StyksPriceFeed</code> contract.</li>
</ul>
<h2>Ideas</h2>
<ul>
<li>Emit CEP95 NFTs on interesting price movements.</li>
<li>When multiple price producers are available, they sync their actions using the
  heartbeat mechanism. If price producers are not in sync</li>
<li>Config for amount of possible missed heartbeats before the price feed is considered invalid.</li>
</ul>
</body>
</html>